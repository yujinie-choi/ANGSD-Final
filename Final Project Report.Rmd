---
title: "ANGSD Final Project"
author: "Yujin Choi  |  April 25, 2023  |  Spring Semester 2023"
output: 
  html_document:
    code_folding: show
    toc: yes
    toc_float: yes
    df_print: paged
    theme: cosmo
---

# 1 Introduction

Biomarkers of aging were used 

**Hypothesis:** Genes differentially expressed across old populations have significant overlap with HGPS compared to the young population. [[1]](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-018-1599-6) 
\

**Dataset:** RNA-seq data of fibroblast cell lines of a wide-range of ages as well as from HGPS patients. [[GEO]](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE113957) [[SRA]](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA454681)

* 10 samples (<10yo), 10 samples (>80yo), 10 samples (HGPS)
\

# 2 Results

Another brief paragraph summarizing your key insights and possible future experiments/analyses that might enhance your own analysis. Make sure to include a discussion of the limits that your data set has!



# 3 Methods

## 3.1 Dataset

Used RNA-seq data generated by Salk Institute's for Biological Studies that was taken from Human dermal fibroblast cell lines from patients of a wide-range of ages as well as 10 samples from HGPS patients. [[GEO]](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE113957) [[SRA]](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA454681) The samples were prepared using Illumina TruSeq Stranded mRNA kit using Poly-A selection and the data is Single-end Stranded with read lengths of 51bp and 75bp. Majority of the samples are run on NextSeq 500 but some run on Illumina HiSeq 2500.

---

All data processing and QC scripts can be found in the [GitHub Repo](https://github.com/laurelis/ANGSD-Final/tree/main/Bash%20Scripts). 

---

## 3.2 Pre-processing

From the RNA-seq dataset I selected for three conditions: 

* 10 samples (<10yo), 10 samples (>80yo), 10 samples (HGPS)

```{r, explore-samples, eval=FALSE}
young=`awk -F ',' '$2<10 {print $1}' SraRunTable.txt | head -n 10`
old=`awk -F ',' '$2>80 {print $1}' SraRunTable.txt | head -n 11 | tail -n +2`
hgps=`awk -vFPAT='([^,]*)|("[^"]+")' -vOFS=, '$15 == "HGPS" {print $1}' SraRunTable.txt`
`echo $young $old $hgps` > SRR_accession_IDs.txt
```

```{}
SRR7093809 SRR7093874 SRR7093875 SRR7093876 SRR7093877 SRR7093878 SRR7093879 SRR7093880 SRR7093881 SRR7093882 SRR7093851 SRR7093852 SRR7093853 SRR7093854 SRR7093855 SRR7093856 SRR7093857 SRR7093858 SRR7093859 SRR7093860 SRR7093942 SRR7093943 SRR7093944 SRR7093945 SRR7093946 SRR7093947 SRR7093948 SRR7093949 SRR7093950 SRR7093951
```

Made sure that these samples all have a read length of `75bp` and are run on `NextSeq 500`. 

```{r, sra-samples}

toc <- read.table('Files/SRA-to-Condition.txt',sep='\t')
sra.table <- read.table('Files/SraRunTable.txt',sep='\t', header=TRUE)
row.names(sra.table) <- sra.table$Run
sra.table[toc[,1],]

```

## 3.3 Indexing and Alignment

Although the original paper aligned to `hg19`, I aligned to the Human reference genome [GRCh38.p13](https://ftp.ensembl.org/pub/release-109/fasta/homo_sapiens/dna/) with `STAR` using the [gene annotation file (version 109)](https://ftp.ensembl.org/pub/release-109/gtf/homo_sapiens/) from ENSEMBL. 

When indexing the genome with `STAR` changed the `--sjdbOverhang` parameter to `74bp` to account for our sample read length.

```{r, genome-index, eval=FALSE}
STAR --runMode genomeGenerate --runThreadN 1 \
        --genomeDir /athena/angsd/scratch/yuc4017/genome/index \
        --genomeFastaFiles /athena/angsd/scratch/yuc4017/genome/Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa \
        --sjdbGTFfile /athena/angsd/scratch/yuc4017/genome/Homo_sapiens.GRCh38.109.gtf \
        --sjdbOverhang 74
```
\

All the sample `fastq` files were downloaded from SRA and aligned to the reference genome with `STAR` default parameters and indexed with `samtools`.

```{r, align-reads, eval=FALSE}
STAR --runMode alignReads \
    		--runThreadN 1 \
    		--genomeDir /athena/angsd/scratch/yuc4017/genome/index \
    		--readFilesIn /athena/angsd/scratch/yuc4017/fastq/${ID}.fastq.gz \
    		--readFilesCommand zcat \
     		--outFileNamePrefix /athena/angsd/scratch/yuc4017/alignments/${ID}. \
    		--outSAMtype BAM SortedByCoordinate

samtools index /athena/angsd/scratch/yuc4017/alignments/${ID}.Aligned.sortedByCoord.out.bam
```
\



## 3.4 FastQC Results

`FastQC` was ran before `featureCounts` to determine quality of reads.

![**Fig. 1. FastQC results - Quality Scores, Sequence Content, GC Distribution:** Alignment quality was good across all sample reads. Although the Sequence Duplication was high this is normally found in RNA-Seq data. There was no significant adapter contamination and it was not necesssary to trim the reads.](./Images/fastqc_results.png)

![**Fig. 2. FastQC results for STAR alignment - STAR Alignment Plot:** STAR Alignment scores are good with mostly Uniquely Mapped reads. We do see that some samples seem to have significantly more sequencing depth than others.](./Images/star_alignment_plot.png)

## 3.5 FeatureCounts

`FeatureCounts` was ran specifying the reverse strand `-s 2`, otherwise everything was ran on default parameters.

```{r, featurecounts, eval=FALSE}
featureCounts -s 2 --minOverlap 1 -a /athena/angsd/scratch/yuc4017/genome/Homo_sapiens.GRCh38.109.gtf -o featureCounts.txt /athena/angsd/scratch/yuc4017/alignments/*.bam

```

Download the hg38 Housekeeping Genes `BED` file from [RseQC's SourceForge](https://sourceforge.net/projects/rseqc/files/BED/Human_Homo_sapiens/), then remove the `chr` on the chromosome labels to be compatible with Ensembl aligned reads. 

```{}
sed "s/^chr//" /athena/angsd/scratch/yuc4017/hg38.HouseKeepingGenes.bed > /athena/angsd/scratch/yuc4017/hg38.HouseKeepingGenes.nochr.bed
```

Then, ran samples through `rseqc` and `qorts`.

```{r, qc, eval=FALSE}
qorts -Xmx18G QC --singleEnded --stranded --generatePlots ${SAMPLE} /athena/angsd/scratch/yuc4017/genome/Homo_sapiens.GRCh38.109.gtf /athena/angsd/scratch/yuc4017/qorts/${ID}/
  
geneBody_coverage.py -i ${SAMPLE} -r /athena/angsd/scratch/yuc4017/hg38.HouseKeepingGenes.nochr.bed -o /athena/angsd/scratch/yuc4017/rseqc/${ID}.rseqc_geneBody_coverage.out

read_distribution.py -i ${SAMPLE} -r /athena/angsd/scratch/yuc4017/hg38.HouseKeepingGenes.nochr.bed > /athena/angsd/scratch/yuc4017/rseqc/${ID}.rseqc_read_distribution.out
```

![**Fig. 3. QoRTs results - Quality Scores, Sequence Content, GC Distribution:** Most of the reads seem to be aligned to a Unique Gene and it is correctly Stranded.](./Images/qorts_results.png)

![**Fig. 4. RSeQC results - Read Distribution, Gene Body Coverage:** There seems to be a high number of intergenic regions compared to QoRTs results, which could be due to gDNA contamination but this might also be due to only using Housekeeping Genes as the gene annotation. The Gene Body Coverage looks fairly good with not much RNA degradation.](./Images/rseqc_results.png)


## 3.6 Exploratory Analyses

```{r libraries, warning=FALSE, message=FALSE, echo=FALSE}

library(tidyverse)
library(reshape2)
library(patchwork)
library(RColorBrewer)
library(ashr)
library(DESeq2)
library(goseq)
library(magrittr)
library(tidyverse)
library(pheatmap)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(EnhancedVolcano)
library(gridExtra)
library(grid)
library(clusterProfiler)
library(enrichplot)


```

**Explore FeatureCounts Summary**

```{r count-table, warning=FALSE, message=FALSE, class.source = 'fold-hide'}

#import SRR to Condition table
toc = read.table('Files/SRA-to-Condition.txt',sep='\t')

#import featureCounts summary data
count_data <- data.table::fread(text="Files/featureCounts.txt.summary", header=TRUE) %>% as.data.frame
orig_names <- names(count_data)

names(count_data) <- gsub(".*(SRR[0-9]+).*", "\\1", orig_names)

count_data <- count_data[rowSums(count_data[,-1])>0,]
count_data <- melt(count_data, value.name = "num_reads", variable.name= "sample")

conditions <- c()
for (i in 1:nrow(count_data)){
  conditions <- append(conditions, toc[toc[,1] == count_data[i,"sample"],][,2])
}

count_data$condition <- conditions
```

```{r summary-graph, warning=FALSE, message=FALSE}

#visualize assigned vs unassigned count for each condition
p_young <- ggplot(count_data[count_data$condition=="young",], aes(fill=Status, y=sample, x=num_reads)) + 
    geom_bar(position="dodge", stat="identity") + 
    theme(legend.position="bottom")
p_young <- p_young + labs(x="# of reads",
              y="samples",
              title="FeatureCounts Summary for Young Samples (<10 yo)")
p_young

p_old <- ggplot(count_data[count_data$condition=="old",], aes(fill=Status, y=sample, x=num_reads)) + 
    geom_bar(position="dodge", stat="identity") + 
    theme(legend.position="bottom")
p_old <- p_old + labs(x="# of reads",
              y="samples",
              title="FeatureCounts Summary for Old Samples (>80 yo)")
p_old

p_hgps <- ggplot(count_data[count_data$condition=="hgps",], aes(fill=Status, y=sample, x=num_reads)) + 
    geom_bar(position="dodge", stat="identity") + 
    theme(legend.position="bottom")
p_hgps <- p_hgps + labs(x="# of reads",
              y="samples",
              title="FeatureCounts Summary for Samples with HGPS")
p_hgps


```

There seems to be a strangely high number of multi-mapping features in one of the HGPS samples `SRR7093948`, but otherwise there is a good ratio of assigned features. There is still comparable sequencing depth to continue using sample `SRR7093948`.

```{r DESeq-object, warning=FALSE, message=FALSE, class.source = 'fold-hide'}

fc_data <- data.table::fread(text="Files/featureCounts.txt", header=TRUE) %>% as.data.frame

orig_names <- names(fc_data)

names(fc_data) <- gsub(".*(SRR[0-9]+).*", "\\1", orig_names)
fc_data_counts <- fc_data[,grepl("SRR", names(fc_data))] %>% dplyr::select(sort(names(.)))
row.names(fc_data_counts)=fc_data$Geneid

toc2 <- toc
rownames(toc2) <- toc2[,1]
toc2[,1] <- NULL
colnames(toc2) <- c("condition")
sample_info <- data.frame(toc2) 
sample_info <- sample_info[sort(rownames(sample_info)), ,drop=F]

#make DESeq object from featureCounts
DESeq.ds <- DESeqDataSetFromMatrix(countData=fc_data_counts, colData=sample_info, design=~condition)
rownames(DESeq.ds) <- fc_data$Geneid
keep_genes <- rowSums(counts(DESeq.ds)) > 0
DESeq.ds <- DESeq.ds[ keep_genes, ]
DESeq.ds$condition %<>% relevel(ref="hgps")

DESeq.ds$color <- as.character(DESeq.ds$condition) 
DESeq.ds$color[DESeq.ds$color=="young"] <- "lightblue"
DESeq.ds$color[DESeq.ds$color=="old"] <- "#4682B4"
DESeq.ds$color[DESeq.ds$color=="hgps"] <- "navy"
```
  
**Normalization**

To account for unequal sequencing depth between conditions (particularly the higher sequencing depth we see in HGPS), we normalize and log transform the data. We check that the normalization and log transform applied correctly. We also reduce variance on the mean of lowly expressed genes with `rlog`.


```{r normalization, warning=FALSE, message=FALSE, fig.height=10, fig.width=15}

#count library sizes of each sample
par(mfrow=c(1,2))
colSums(counts(DESeq.ds)) %>% barplot(., col = DESeq.ds$color, main="Library Sizes", legend=TRUE, args.legend=list(x="topleft", legend=c("young", "old", "hgps"), fill=DESeq.ds$color))

#estimate Size Factors and Normalize Data
DESeq.ds <- estimateSizeFactors(DESeq.ds)
plot( sizeFactors(DESeq.ds), colSums(counts(DESeq.ds)), main="Size Factors", ylab = "library sizes", xlab = "size factors", cex = .6 , col = DESeq.ds$color)

assay(DESeq.ds, "log.counts") <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
assay(DESeq.ds, "log.norm.counts") <- log2(counts(DESeq.ds, normalized=TRUE) + 1)

par(mfrow=c(1,2))
counts.sf_normalized <- counts(DESeq.ds, normalized=TRUE)
boxplot(data.frame(assay(DESeq.ds, "log.counts")), main = "Read Counts Only", cex = .6, horizontal=TRUE, col = DESeq.ds$color)
boxplot(assay(DESeq.ds, "log.norm.counts"), main = "SF normalized", cex = .6, horizontal=TRUE, col = DESeq.ds$color) 

#rlog Transform
DESeq.rlog <- rlog(DESeq.ds, blind = TRUE)

par(mfrow=c(2,3))
DESeq.ds[, c("SRR7093809","SRR7093874")] %>%
  assay(., "log.norm.counts") %>%
  plot(., cex=.1, main = "SRR7093809 vs. SRR7093874", sub="Young vs Young", col="lightblue")

DESeq.ds[, c("SRR7093851","SRR7093852")] %>%
assay(., "log.norm.counts") %>%
plot(., cex=.1, main = "SRR7093851 vs SRR7093852", sub="Old vs Old", col="#4682B4")

DESeq.ds[, c("SRR7093942","SRR7093943")] %>%
assay(., "log.norm.counts") %>%
plot(., cex=.1, main = "SRR7093942 vs SRR7093943", sub="HGPS vs HGPS", col="navy")

DESeq.rlog[, c("SRR7093809","SRR7093874")] %>%
  assay(.) %>%
  plot(., cex=.1, main = "SRR7093809 vs. SRR7093874 \n (normalized)", sub="Young vs Young", col="lightblue")

DESeq.rlog[, c("SRR7093851","SRR7093852")] %>%
assay(.) %>%
plot(., cex=.1, main = "SRR7093851 vs SRR7093852 \n (normalized)", sub="Old vs Old", col="#4682B4")

DESeq.rlog[, c("SRR7093942","SRR7093943")] %>%
assay(.) %>%
plot(., cex=.1, main = "SRR7093942 vs SRR7093943 \n (normalized)", sub="HGPS vs HGPS", col="navy")

```



**Sample-to-Sample Clustering (Heatmap)**

Explore the count data via sample-to-sample clustering and visualize with a heatmap. Unfortuneately we see that the conditions do not seem to separate well using sample-to-sample distance clustering.

```{r pheatmap, warning=FALSE, message=FALSE}

sampleDists <- dist(t(assay(DESeq.ds)))
# sampleDists <- dist(t(rlog.dge))

sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(DESeq.ds$condition, sep="-")
colnames(sampleDistMatrix) <- NULL
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         main="Sample-to-Sample Clustering (Heatmap)")
```

**Principal Component Analysis**

PCA was also used to visualize the similarities between the conditions and this time we see that it separates clearly into groups although the `young` sample `SRR7093878` seems to have made it into the `hgps` group. 

```{r PCA, warning=FALSE, message=FALSE, fig.width=15}

pca <- plotPCA(rlog(DESeq.ds), intgroup=c("condition"))
pca <- pca + geom_label(aes(label = name), position = position_nudge(y = 1))
pca + ggtitle("PCA Analysis of Conditions") + 
    theme(plot.title = element_text(size = 20, face = "bold"))

```

## 3.7 Differential Gene Expression Analysis

We run DESeq on the count data.

```{r DESeq, warning=FALSE, message=FALSE}

hg38 <- org.Hs.eg.db
DESeq.ds <- DESeq(DESeq.ds)

```


Since we want to explore significant genes between `young` vs `hgps` that are not found in `old` vs `hgps` we separate the DESeq results into the different conditional comparisons and find the top 10 significant genes in each condition comparison. Our genes of interested would also have low p-values for `young` vs `hgps` while simultaneously having high p-values for `old` vs `hgps` to account for difference that are purely due to disease expression rather than aging factors.


```{r condition_seperated, warning=FALSE, message=FALSE, class.source = 'fold-hide'}

#young vs old
DGE.results <- results(DESeq.ds,contrast=c("condition","young","old"), independentFiltering = TRUE, alpha=0.05)
DGE.results.sorted <- DGE.results %>% `[`(order(.$padj),)
DGE.genes <- rownames(subset(DGE.results.sorted, padj < 0.05))
DGE.results.shrnk <- lfcShrink(DESeq.ds,contrast=c("condition","old","young"), res=DGE.results, type="ashr")

#young vs hgps
DGE.results.young <- results(DESeq.ds, contrast=c("condition","young","hgps"), independentFiltering = TRUE, alpha=0.05)
DGE.results.young.sorted <- DGE.results.young %>% `[`(order(.$padj),)
DGE.genes.young <- rownames(subset(DGE.results.young.sorted, padj < 0.05))
DGE.results.young.shrnk <- lfcShrink(DESeq.ds,coef=3, type="ashr")

#old vs hgps
DGE.results.old <- results(DESeq.ds, contrast=c("condition","old","hgps"), independentFiltering = TRUE, alpha=0.05)
DGE.results.old.sorted <- DGE.results.old %>% `[`(order(.$padj),)
DGE.genes.old <- rownames(subset(DGE.results.old.sorted, padj < 0.05))
DGE.genes.old.nonsig <- rownames(subset(DGE.results.old.sorted, padj > 0.05))
DGE.results.old.shrnk <- lfcShrink(DESeq.ds,coef=2, type="ashr")

# top 10 significant genes in each condition correlations
most.significant.genes_df <- data.frame (first_column  = head(DGE.genes, 10),
                              second_column = "young vs old") %>% rbind(., data.frame(first_column  = head(DGE.genes.young, 10),
                              second_column = "young vs hgps")) %>% rbind(., data.frame(first_column  = head(DGE.genes.old, 10),
                              second_column = "old vs hgps")) 
colnames(most.significant.genes_df) <- c("ENSEMBL", "CONDITIONS")

annot.DGE.genes <- AnnotationDbi::select(hg38, keys=most.significant.genes_df$ENSEMBL, keytype="ENSEMBL", columns=c("GENENAME"))
annot.DGE.genes$CONDITIONS <- most.significant.genes_df$CONDITIONS
annot.DGE.genes

```


**DGE Heatmap**

Since I want to explore the significant genes between `young` vs `hgps` that are not present in `old` vs `hgps` I first use the DGE heatmap to visualize whether there are genes that fulfill this requirement.

Looking at the row-based z-score heatmap of the DGE between conditions we can see that the `hgps` group indeed seems to have increased expression similar to the `old` condition samples that is not seen in the `young` samples.

```{r dgeheatmap, warning=FALSE, message=FALSE}

DGEgenes <- rownames(subset(DGE.results.sorted, padj < 0.05))
rlog.dge <- DESeq.rlog[DGEgenes,] %>% assay
colnames(rlog.dge) <- DESeq.ds$condition

# heatmap of DEG sorted by p.adjust
pheatmap(rlog.dge, scale="row",
show_rownames=FALSE, main="DGE (row-based z-score)")
```

*Count Plots*

Now that we have confirmed relevant genes exist, we will now inspect the expression values of significant genes for `young` vs `hgps`. Our genes of interested would also have low p-values for `young` vs `hgps` while simultaneously having high p-values for `old` vs `hgps` to account for difference that are purely due to disease expression rather than aging factors.

```{r plotCounts, warning=FALSE, message=FALSE, fig.height=10}

#significant genes (sig young vs hgps, non-sig old vs hgps)
DGE.conditional.genes <- DGE.genes.young[DGE.genes.young %in% DGE.genes.old.nonsig]
annot.DGE <- AnnotationDbi::select(hg38, keys=DGE.conditional.genes, keytype="ENSEMBL", columns=c("SYMBOL", "ALIAS", "GENENAME"))
DGE.results.young.shrnk.filtered <- DGE.results.young.shrnk[DGE.conditional.genes,]
head(annot.DGE, 20)

#plotCounts  
par(mfrow=c(3,2))
plotCounts(DESeq.ds, gene = "ENSG00000237973", main = "ENSG00000196205  \n GENENAME: MT-CO1 pseudogene 12")
plotCounts(DESeq.ds, gene = "ENSG00000162595", xlab="", main = "ENSG00000101384 \n GENENAME: DIRAS family GTPase 3")
plotCounts(DESeq.ds, gene = "ENSG00000225972", xlab="", main = "ENSG00000070087 \n GENENAME: MT-ND1 pseudogene 23")
plotCounts(DESeq.ds, gene = "ENSG00000070756", xlab="", main = "ENSG00000123612 \n GENENAME: poly(A) binding protein cytoplasmic 1")
plotCounts(DESeq.ds, gene = "ENSG00000183196", xlab="", main = "ENSG00000102471 \n GENENAME: carbohydrate sulfotransferase 6")
plotCounts(DESeq.ds, gene = "ENSG00000160789", xlab="", main = "ENSG00000160789 \n GENENAME: lamin A/C")

```


*MA Plot*

Visualize the statistically significant genes (shrunk for noisy/lowly expressed data) for all of our conditions.

```{r MA-plot, warning=FALSE, message=FALSE}

par(mfrow=c(1,3))

#young vs old
plotMA(DGE.results.shrnk, alpha=0.05, main="Young vs Old: p.adj.value < 0.05", ylim=c(-4,4))

#young vs hgps
plotMA(DGE.results.young.shrnk, alpha=0.05, main="Young vs HGPS: p.adj.value < 0.05", ylim=c(-4,4))

#old vs hgps
plotMA(DGE.results.old.shrnk, alpha=0.05, main="Old vs HGPS: p.adj.value < 0.05", ylim=c(-4,4))


```

**Volcano Plot**

Looking at our top 10 genes of significant value for `young vs hgps` and `old vs hgps` and comparing against the top 10 genes that had significant values for `young vs hgps` while being filtered for non-significant value `old vs hgps` genes on a Volcano Plot.  

```{r volcano-plot, warning=FALSE, message=FALSE, fig.width=20}

#old vs hgps
p3 <- EnhancedVolcano(DGE.results.old.shrnk, lab=rownames(DGE.results.old.shrnk), x="log2FoldChange", y="padj", pCutoff=0.05, title="Old vs HGPS", boxedLabels = TRUE, selectLab = annot.DGE.genes[annot.DGE.genes$CONDITIONS =="old vs hgps",]$ENSEMBL)

#young vs hgps
p4 <- EnhancedVolcano(DGE.results.young.shrnk, lab=rownames(DGE.results.young.shrnk), x="log2FoldChange", y="padj", pCutoff=0.05, title="Young vs HGPS", boxedLabels = TRUE, selectLab = annot.DGE.genes[annot.DGE.genes$CONDITIONS =="young vs hgps",]$ENSEMBL)

grid.arrange(p3, p4,
  ncol = 2)

#old vs hgps (filtered)
p1 <- EnhancedVolcano(DGE.results.old.shrnk, lab=rownames(DGE.results.old.shrnk), x="log2FoldChange", y="padj", pCutoff=0.05, title="Old vs HGPS (Filtered)", boxedLabels = TRUE, selectLab = head(annot.DGE$ENSEMBL, 20))

#young vs hgps (filtered)
p2 <- EnhancedVolcano(DGE.results.young.shrnk, lab=rownames(DGE.results.young.shrnk), x="log2FoldChange", y="padj", pCutoff=0.05, title="Young vs HGPS (Filtered)", boxedLabels = TRUE, selectLab = head(annot.DGE$ENSEMBL, 20))

grid.arrange(p1, p2,
  ncol = 2)

```

*Gene Set Enrichment Analysis*

Run GSEA on GO terms for our different conditions: `old vs hgps`, `young vs hgps`, and `young vs hgps (filtered)`. Surprisingly we find that the most significant gene set is the Golgi vesicle transport for `young vs hgps` regardless of whether it is filtered or not.

```{r clusterprofiler, warning=FALSE, message=FALSE}

#old vs hgps
gene_list.old <- DGE.results.old$log2FoldChange
names(gene_list.old) <- rownames(DGE.results.old)
gene_list.old<-na.omit(gene_list.old)
gene_list.old <- sort(gene_list.old, decreasing = TRUE)
gse.old <- gseGO(gene_list.old, ont = "ALL", keyType="ENSEMBL", OrgDb = hg38, eps =1e-300)

#young vs hgps
gene_list.young <- DGE.results.young$log2FoldChange
names(gene_list.young) <- rownames(DGE.results.young)
gene_list.young<-na.omit(gene_list.young)
gene_list.young <- sort(gene_list.young, decreasing = TRUE)
gse.young <- gseGO(gene_list.young, ont = "ALL", keyType="ENSEMBL", OrgDb = hg38, eps =1e-300)

#young vs hgps (filtered)
gene_list.young.filtered <- gene_list.young[DGE.conditional.genes]
gse.young.filtered <- gseGO(gene_list.young, ont = "ALL", keyType="ENSEMBL", OrgDb = hg38, eps =1e-300)
as.data.frame(gse.young.filtered)



```

```{r clusterprofiler-plots, warning=FALSE, message=FALSE, fig.height=10, fig.width=8}

dotplot(gse.old, showCategory=10, split=".sign") + facet_grid(.~.sign) +  ggtitle("Old vs HGPS")
gseaplot(gse.old, geneSetID = 1, title = "Muscle Organ Development (Old vs HGPS)")

dotplot(gse.young, showCategory=10, split=".sign") + facet_grid(.~.sign) + ggtitle("Young vs HGPS")
gseaplot(gse.young, geneSetID = 1, title = "Golgi vesicle transport (Young vs HGPS)") 

dotplot(gse.young.filtered, showCategory=10, split=".sign") + facet_grid(.~.sign) + ggtitle("Young vs HGPS (filtered)")
gseaplot(gse.young.filtered, geneSetID = 1, title = "Golgi Vesicle Transport (Filtered Young vs HGPS)") 

```

Performed GSEA with a gene set of consistently over-expressed and under-expressed genes corresponding to age, based on meta-analysis of microarray data found on the GSEA website [AGING_UP](https://www.gsea-msigdb.org/gsea/msigdb/cards/DEMAGALHAES_AGING_UP)[AGING_DN](https://www.gsea-msigdb.org/gsea/msigdb/human/geneset/DEMAGALHAES_AGING_DN.html).

Unfortunately there were no significant enrichment for the aging over-expressed genes, even in the `old` vs `young` conditions which were also included to test the validity of the gene set. However in the aging under-expressed genes we see that there is an enrichment when comparing the `young` vs `old` conditions.

```{r aging-geneset, warning=FALSE, message=FALSE, fig.height=10}

# gmt.up_df <- read.gmt("Files/DEMAGALHAES_AGING_UP.v2023.1.Hs.gmt")
# gmt.down_df <- read.gmt("Files/DEMAGALHAES_AGING_DN.v2023.1.Hs.gmt")
# 
# annot.up.gmt <- AnnotationDbi::select(hg38, keys=gmt.up_df$gene, keytype="SYMBOL", columns="ENSEMBL", multiVals="first")
# annot.down.gmt <- AnnotationDbi::select(hg38, keys=gmt.down_df$gene, keytype="SYMBOL", columns="ENSEMBL", multiVals="first")
# 
# annot.up.gmt <- annot.up.gmt[!duplicated(annot.up.gmt$SYMBOL), ]
# annot.down.gmt <- annot.down.gmt[!duplicated(annot.down.gmt$SYMBOL), ]
# gmt.up_df$gene <- annot.up.gmt$ENSEMBL
# gmt.down_df$gene <- annot.down.gmt$ENSEMBL
# 
# gene_list<- sort(gene_list, decreasing = TRUE)
# gene_list.young<- sort(gene_list.young, decreasing = TRUE)
# gene_list.old<- sort(gene_list.old, decreasing = TRUE)
# gene_list.young.filtered<- sort(gene_list.young.filtered, decreasing = TRUE)
# 
# gse.up.agingset <- GSEA(gene_list, TERM2GENE = gmt.up_df, pvalueCutoff = 1)
# gse.up.agingset.young <- GSEA(gene_list.young, TERM2GENE = gmt.up_df, pvalueCutoff = 1)
# gse.up.agingset.young.filtered <- GSEA(gene_list.young.filtered, TERM2GENE = gmt.up_df, pvalueCutoff = 1)
# 
# gse.down.agingset <- GSEA(gene_list, TERM2GENE = gmt.down_df, pvalueCutoff = 1)
# gse.down.agingset.young <- GSEA(gene_list.young, TERM2GENE = gmt.down_df, pvalueCutoff = 1)
# gse.down.agingset.young.filtered <- GSEA(gene_list.young.filtered, TERM2GENE = gmt.down_df, pvalueCutoff = 1)

# gseaplot(gse.up.agingset, geneSetID = 1)
# gseaplot(gse.up.agingset.young, geneSetID = 1)
# gseaplot(gse.up.agingset.young.filtered, geneSetID = 1)
# 
# gseaplot(gse.down.agingset, geneSetID = 1)
# gseaplot(gse.down.agingset.young, geneSetID = 1)
# gseaplot(gse.down.agingset.young.filtered, geneSetID = 1)


```

# 4 Discussion

A brief description/list of issues/problems/limitations you encountered along the way and how you addressed them.
A table that summarizes the key data sets that you have generated during the analyses and decided to keep.

There seems to be a strangely high number of multi-mapping features in one of the HGPS samples `SRR7093948` which doesn't reflect in QoRTs results. Compared to the other samples, `SRR7093948` did have a higher percentage of reads mapped to multiple loci (other samples ~5% where as this sample was at ~11%) but interestingly it is not reflected in QoRTs. 


### 4.1 Repository

Link to GitHub Repo is [here](https://github.com/laurelis/ANGSD-Final).


